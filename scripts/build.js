#!/usr/bin/env node

/**
 * NOTE: All source code files generated by this script run from a `temp` folder placed
 * in the project root.  This script uses relative paths to link to files in the `src` folder.
 * The paths in these generated files may vary from the regular files used.
 *
 * Custom Build Steps:
 *
 * 1. Generate a list of component source code files based on what we've provided
 *    in args.  No args == all components.
 * 2. Sort requested components into a few logical groups (TBD) to be imported/exported
 *    in a specific order (which matters).
 * 3. Render both of the following:
 *    - an `index.js` file with ES6-based import/export statements
 *    - an `index.scss` file with SASS-based import statements
 * 4. Pass these files into Rollup/Node-Sass config and run the normal builds.
 * 5. Add the results of these builds to the `/dist` folder as usual.
 *
 * Order of included libraries matters per group:
 * - Core (required, canâ€™t be removed)
 * - Behaviors (not required but will be added if required by bundled components)
 * - Rules Libraries (Mask, Validation, Datagrid) (not required unless these components are used)
 * - Patterns
 * - Layouts
 * - Foundational Components
 * - Mid-Level Components (includes Charts)
 * - Complex Components
 */

const argv = require('yargs').argv;
const fs = require('fs');
const path = require('path');

const logger = require('./logger');

/*
const requiredComponents = [];
const behaviors = [];

if (!argv.components) {

}
*/

// -------------------------------------
//   Functions
// -------------------------------------

/**
 * Returns a string with a capitalized first letter
 * @param {string} str incoming string
 * @returns {string} the capitalized string
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Checks the type of library.
// Sets to `components` if it's not a valid one.
const libTypes = ['behaviors', 'components', 'layouts', 'patterns', 'utils'];
function checkLibType(type) {
  if (libTypes.indexOf(type) < 0) {
    type = libTypes[1];
  }
  return type;
}

/**
 * Returns a string representing a valid Javascript ES6 `import` statement
 * @param {string} libFile the target library file
 * @param {string} type the type of libary file
 * @returns {string} a valid ES6 `import` statement
 */
function writeJSImportStatement(libFile, type) {
  const constructorName = capitalize(libFile, type);
  type = checkLibType(type);
  return `import { ${constructorName} } from '../src/${type}/${libFile}/${libFile}';`;
}

/**
 * Returns a string representing a valid SASS `@import` statement
 * @param {string} libFile the target library file
 * @param {string} type the type of libary file
 * @returns {string} a valid SASS `@import` statement
 */
function writeSassImportStatement(libFile, type) {
  type = checkLibType(type);
  return `@import '../src/${type}/${libFile}/${libFile}';`;
}

/**
 * Gets a complete list of files inside the source code directory.
 * @returns {Promise} resolved once filesystem is read
 */
function getSourceFolderContents() {
  const srcDir = path.join(__dirname, '..', 'src');
  return new Promise((resolve, reject) => {
    fs.readdir(srcDir, (err, items) => {
      if (err) {
        reject(new Error(err.message));
        return;
      }

      resolve(items);
    });
  });
}

// -------------------------------------
//   Main
// -------------------------------------

let buildOutput;

// Scan source code directories
getSourceFolderContents().then((items) => {
  items.forEach((item) => {
    buildOutput += `${item}\n`;
  });

  logger(buildOutput);
  debugger;
});
