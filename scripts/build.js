#!/usr/bin/env node

/**
 * NOTE: All source code files generated by this script run from a `temp` folder placed
 * in the project root.  This script uses relative paths to link to files in the `src` folder.
 * The paths in these generated files may vary from the regular files used.
 *
 * Custom Build Steps:
 *
 * 1. Generate a list of component source code files based on what we've provided
 *    in args.  No args == all components.
 * 2. Sort requested components into a few logical groups (TBD) to be imported/exported
 *    in a specific order (which matters).
 * 3. Render both of the following:
 *    - an `index.js` file with ES6-based import/export statements
 *    - an `index.scss` file with SASS-based import statements
 * 4. Pass these files into Rollup/Node-Sass config and run the normal builds.
 * 5. Add the results of these builds to the `/dist` folder as usual.
 *
 * Order of included libraries matters per group:
 * - Core (required, canâ€™t be removed)
 * - Behaviors (not required but will be added if required by bundled components)
 * - Rules Libraries (Mask, Validation, Datagrid) (not required unless these components are used)
 * - Patterns
 * - Layouts
 * - Foundational Components
 * - Mid-Level Components (includes Charts)
 * - Complex Components
 */

const argv = require('yargs').argv;
const chalk = require('chalk');
const del = require('del');
const fs = require('fs');
const path = require('path');

const logger = require('./logger');

const SRC_DIR = path.join(__dirname, '..', 'src');
const TEMP_DIR = path.join(__dirname, '..', 'temp');
const RELATIVE_SRC_DIR = path.join('..', 'src');
const RELATIVE_TEMP_DIR = path.join('..', 'temp');

const filePaths = {
  src: {
    js: {
      behaviors: path.join(SRC_DIR, 'behaviors', 'behaviors.js'),
      components: path.join(SRC_DIR, 'components', 'components.js'),
      index: path.join(SRC_DIR, 'index.js'),
      patterns: path.join(SRC_DIR, 'patterns', 'patterns.js'),
    },
    jQuery: {
      behaviors: path.join(SRC_DIR, 'behaviors', 'behaviors.jquery.js'),
      components: path.join(SRC_DIR, 'components', 'components.jquery.js'),
      patterns: path.join(SRC_DIR, 'patterns', 'patterns.jquery.js'),
    },
    sass: {
      themes: {
        dark: path.join(SRC_DIR, 'themes', 'dark-theme.scss'),
        'high-contrast': path.join(SRC_DIR, 'themes', 'high-contrast-theme.scss'),
        light: path.join(SRC_DIR, 'themes', 'light-theme.scss'),
        uplift: path.join(SRC_DIR, 'themes', 'uplift-theme.scss'),
      }
    }
  },
  target: {
    js: {
      behaviors: path.join(TEMP_DIR, 'behaviors.js'),
      components: path.join(TEMP_DIR, 'components.js'),
      index: path.join(TEMP_DIR, 'index.js'),
      patterns: path.join(TEMP_DIR, 'patterns.js'),
      rules: path.join(TEMP_DIR, 'rules.js')
    }
  }

};

const searchTerms = {
  complex: '// Complex ====/',
  foundational: '// Foundational ====/',
  mid: '// Mid ====/'
};

// TOOD: Replace with command line args
const TEST_ARGS = [
  'button',
  'input',
  'mask',
  'listview',
  'list-detail',
  'longpress',
  'popupmenu',
  'tabs',
  'validation'
];

// Library types
const libTypes = ['components', 'behaviors', 'layouts', 'patterns', 'utils'];

// All incoming scanned source code is labeled as "components" by default.
// If the source code folder shows up as a property here, it will be moved to a different
// bucket.
const customLocations = {
  masks: 'rules',
  'mask-api': '',
  'mask-input': 'foundational',
  'tabs-multi': 'complex',
  validation: 'rules',
  'validation.utils': '',
  validator: 'foundational'
};

// Storage buckets for relevant file paths.
// These get used for generating import/export statements
const buckets = {
  behaviors: [],
  rules: [],
  foundational: [],
  mid: [],
  complex: [],
  layouts: [],
  patterns: []
};

// -------------------------------------
//   Functions
// -------------------------------------

/**
 * Returns a string with a capitalized first letter
 * @param {string} str incoming string
 * @returns {string} the capitalized string
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Converts a library file's name to a matching string that will be
 * used to target an imported/exported library constructor.  This happens by replacing
 * filenames that use dashes followed by lowercase letters, to uppercase letters.
 * @param {string} str incoming string representing a filename
 * @returns {string} containing a matching constructor
 */
function replaceDashesWithCaptials(str) {
  str = capitalize(str);

  const matches = str.match(/(-\w)+/g);
  if (!matches) {
    return str;
  }

  matches.forEach((match) => {
    str = str.replace(match, capitalize(match.replace('-', '')));
  });
  return str;
}

/**
 * @param {string} str incoming string containing a file path
 * @returns {string} a string containing just a filename
 */
function getFileName(str) {
  const lastSlash = str.lastIndexOf(path.sep);
  if (lastSlash === -1 || lastSlash === (str.length - 1)) {
    return str;
  }
  return str.slice(lastSlash + 1);
}

/**
 * @param {string} str containing a file name
 * @returns {string} the library name
 */
function getLibFromFileName(str) {
  const dot = str.indexOf('.');
  return str.substring(0, dot);
}

/**
 * @param {string} str containing a file name
 * @returns {string} the library path without the filename
 */
function getPath(str) {
  const lastSlash = str.lastIndexOf(path.sep);
  if (lastSlash === -1 || lastSlash === (str.length - 1)) {
    return str;
  }
  return str.substring(0, lastSlash + 1);
}

/**
 * Returns a string representing a valid Javascript ES6 `import` statement
 * @param {string} libFile the target library file
 * @param {string} libFolder the target library folder
 * @returns {string} a valid ES6 `import` statement
 */
function sanitizeLibFile(libFile, libFolder) {
  libFile = libFile.toLowerCase();
  if (!libFolder) {
    libFolder = libFile;
  } else {
    libFolder = libFolder.toLowerCase();
  }
  return libFile;
}

/**
 * Returns a string representing a valid Javascript ES6 `import` statement
 * @param {string} libFile the target library file
 * @param {string} libPath the target library folder
 * @param {boolean} isExport if true, export statement is used instead.
 * @returns {string} a valid ES6 `import` statement
 */
function writeJSImportStatement(libFile, libPath, isExport) {
  const constructorName = replaceDashesWithCaptials(libFile);
  libFile = sanitizeLibFile(libFile, libPath);
  const command = isExport ? 'export' : 'import';
  return `${command} { ${constructorName} } from '${RELATIVE_SRC_DIR}/${libPath}${libFile}';`;
}

/**
 * Returns a string representing a valid SASS `@import` statement
 * @param {string} libFile the target library file
 * @param {string} libPath the target libary folder
 * @returns {string} a valid SASS `@import` statement
 */
function writeSassImportStatement(libFile, libPath) {
  libFile = sanitizeLibFile(libFile, libPath);
  return `@import '${RELATIVE_SRC_DIR}/${libPath}${libFile}';`;
}

/**
 * @param {array} dirs an array of strings representing directories
 * @returns {void}
 */
function createDirs(dirs) {
  dirs.forEach((dir) => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir);
      logger('info', `Created directory "${dir}"`);
    }
  });
}

/**
 * "cleans" all the folders used by this script
 * @returns {Promise} that resolves when the `del` library completes its task
 */
function cleanAll() {
  const filesToDel = [
    `${TEMP_DIR}/*.js`,
    `${TEMP_DIR}/*.scss`
  ];

  return del(filesToDel)
    .catch(err => logger('error', `Error: ${err}`))
    .then(() => {
      logger('success', `Cleaned directory "${TEMP_DIR}"`);
      createDirs([TEMP_DIR]);
    });
}

/**
 * Wraps `fs.readdir` and does a recursive file search
 * @param {string} root ?
 * @param {function} filter ?
 * @param {array} files ?
 * @param {string} prefix ?
 * @returns {array} of found files
 */
function read(root, filter, files, prefix) {
  prefix = prefix || '';
  files = files || [];
  filter = filter || function (x) {
    return x[0] !== '.' && !x.endsWith('.md');
  };

  const dir = path.join(root, prefix);
  if (!fs.existsSync(dir)) {
    return files;
  }

  if (fs.statSync(dir).isDirectory()) {
    fs.readdirSync(dir)
      .filter((name, index) => filter(name, index, dir))
      .forEach((name) => {
        read(root, filter, files, path.join(prefix, name));
      });
  } else {
    files.push(prefix);
  }

  return files;
}

/**
 * @param {array} files incoming file list
 * @param {string} term used for filtering the file list
 * @returns {array} a filtered version of the incoming array
 */
function searchFileNames(files, term) {
  const results = [];
  if (!Array.isArray(files) || !files.length || !term) {
    return results;
  }

  files.forEach((file) => {
    if (file.indexOf(term) > -1) {
      results.push(file);
    }
  });

  return results;
}

/**
 * Gets a copy of the standard `index.js` file.
 * @param {string} filePath the target file to be read.
 * @returns {string} containing the imported file.
 */
function getFileContents(filePath) {
  return fs.readFileSync(filePath, 'utf8');
}

/**
 * @param {string} str the string to search
 * @param {string} term the term to find
 * @returns {number} the location index of the search term, plus the term's length
 */
function getFurthestIndexOf(str, term) {
  return str.indexOf(term) + term.length;
}

/**
 * Sort Locations
 * @param {array} files incoming list of file paths
 */
function sortLocations(files) {
  const matchStr = libTypes.slice(1).join('|');
  const matchRegex = new RegExp(matchStr, 'g');
  const locationKeys = Object.keys(customLocations);

  const componentsJSFile = getFileContents(filePaths.src.js.components);
  const startOfMid = getFurthestIndexOf(componentsJSFile, searchTerms.mid);
  const startOfComplex = getFurthestIndexOf(componentsJSFile, searchTerms.complex);

  files.forEach((file) => {
    let match = file.match(matchRegex);
    // No match === 'component' type.  In this case, further sort the sub-component type
    if (!match) {
      const fileName = getFileName(file);
      const lib = getLibFromFileName(fileName);

      // If the `lib` is defined with a custom location in this script,
      // prefer the bucket associated with it.
      if (locationKeys.indexOf(lib) !== -1) {
        const bucketKey = customLocations[lib];
        const bucket = buckets[bucketKey];
        if (Array.isArray(bucket)) {
          bucket.push(file);
        }
        return;
      }

      // Scan the `components.js` file for the location of this lib's name,
      // and determine its bucket placement based on its index,
      // compared to the headers' index in that file.
      const indexInJSFile = componentsJSFile.indexOf(lib);
      let targetBucket = buckets.foundational;
      if (indexInJSFile > startOfComplex) {
        targetBucket = buckets.complex;
      } else if (indexInJSFile > startOfMid) {
        targetBucket = buckets.mid;
      }

      targetBucket.push(file);
      return;
    }

    // Use first result
    match = match[0];

    // Ignore `utils` type for components
    if (match === 'utils') {
      return;
    }

    try {
      buckets[match].push(file);
    } catch (e) {
      throw new Error(`Sort Error: ${e}`);
    }
  });
}

/**
 * Writes the contents of a single file bucket to a string, for being appended to a file
 * @param {string} key the target file bucket
 * @returns {string} formatted, multi-line, containing all relevant ES6-based import/export statements
 */
function renderImportsToString(key) {
  let fileContents = '';
  const bucket = buckets[key];
  if (!Array.isArray(bucket)) {
    throw new Error(`No bucket with name "${key}" exists.`);
  }

  bucket.forEach((srcFilePath) => {
    const fileName = getFileName(srcFilePath);
    const filePath = getPath(srcFilePath);
    const lib = getLibFromFileName(fileName);

    let useImportStatement = true;
    //if (false) {
    //  useImportStatement = false;
    //}

    // TODO: make this not always export
    const statement = writeJSImportStatement(lib, filePath, useImportStatement);
    fileContents += `${statement}\n`;
  });

  return fileContents;
}

/**
 * Writes a JS file containing regular ES6 Imports (not jQuery)
 * @private
 * @param {string} key the file path bucket to use
 * @param {string} targetFilePath the path of the file that will be written
 * @returns {void}
 */
function renderTargetJSFile(key, targetFilePath) {
  let targetFile = '';

  if (key === 'index') {
    // Pull in the standard `index.js` file and create a custom version that links
    // out to other JS files that will import slimmed-down lists of components.
    // Saves to the `temp/` folder.
    targetFile = getFileContents(filePaths.src.js.index);
    targetFile = targetFile
      .replace(/('\.\/)/g, '\'../src/')
      .replace('../src/behaviors/behaviors', './behaviors')
      .replace('../src/core/rules', './rules')
      .replace('../src/components/components', './components')
      .replace('../src/patterns/patterns', './patterns');
  } else if (key === 'components') {
    // 'component' source code files are comprised of three buckets that need to
    // be written to the target file in a specific order.
    const componentBuckets = ['foundational', 'mid', 'complex'];
    componentBuckets.forEach((thisBucket) => {
      targetFile += `// ${capitalize(thisBucket)} ====/\n`;
      targetFile += renderImportsToString(thisBucket);
    });
  } else {
    // All other buckets simply get rendered directly
    targetFile += renderImportsToString(key, targetFile);
  }

  fs.writeFileSync(targetFilePath, targetFile);
}

/**
 * Renders all available target files.
 * @returns {void}
 */
function renderTargetFiles() {
  const jsEntryPoints = Object.keys(filePaths.target.js);
  jsEntryPoints.forEach((filePathKey) => {
    renderTargetJSFile(filePathKey, filePaths.target.js[filePathKey]);
  });
}

// -------------------------------------
//   Main
// -------------------------------------

logger(null, `\n${chalk.red.bold('IDS Enterprise Custom Builder')}\n`);

let buildOutput = '\n';

// Reset all build folders to a `cleaned` state.
cleanAll().then(() => {
  // Scan source code directories
  const items = read(SRC_DIR);

  // Build several lists of component source code files that match what was requested
  const jsMatches = [];
  const jQueryMatches = [];
  const sassMatches = [];
  TEST_ARGS.forEach((arg) => {
    const results = searchFileNames(items, arg);
    results.forEach((result) => {
      let renderTarget = jsMatches;
      if (result.indexOf('.jquery') > -1) {
        renderTarget = jQueryMatches;
      }
      if (result.endsWith('.scss')) {
        renderTarget = sassMatches;
      }
      if (renderTarget.indexOf(result) > -1) {
        return;
      }
      renderTarget.push(result);
    });
  });

  buildOutput += `${chalk.cyan('JS Source Code:')}\n`;
  jsMatches.forEach((item) => {
    buildOutput += `${item}\n`;
  });
  buildOutput += '\n';

  buildOutput += `${chalk.cyan('jQuery Source Code:')}\n`;
  jQueryMatches.forEach((item) => {
    buildOutput += `${item}\n`;
  });
  buildOutput += '\n';

  buildOutput += `${chalk.cyan('SASS Source Code:')}\n`;
  sassMatches.forEach((item) => {
    buildOutput += `${item}\n`;
  });

  // Create customized lists of JS components for this bundle
  sortLocations(jsMatches);
  renderTargetFiles();

  // TODO: Pull in the standard `_controls.sass` and create a custom version
  // that links out to other SASS files that will import slimmed-down lists of components.
  // Saves to the `temp/` folder.

  process.stdout.write(buildOutput);
});
