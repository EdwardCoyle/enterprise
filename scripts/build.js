#!/usr/bin/env node

/**
 * NOTE: All source code files generated by this script run from a `temp` folder placed
 * in the project root.  This script uses relative paths to link to files in the `src` folder.
 * The paths in these generated files may vary from the regular files used.
 *
 * Custom Build Steps:
 *
 * 1. Generate a list of component source code files based on what we've provided
 *    in args.  No args == all components.
 * 2. Sort requested components into a few logical groups (TBD) to be imported/exported
 *    in a specific order (which matters).
 * 3. Render both of the following:
 *    - an `index.js` file with ES6-based import/export statements
 *    - an `index.scss` file with SASS-based import statements
 * 4. Pass these files into Rollup/Node-Sass config and run the normal builds.
 * 5. Add the results of these builds to the `/dist` folder as usual.
 *
 * Order of included libraries matters per group:
 * - Core (required, canâ€™t be removed)
 * - Behaviors (not required but will be added if required by bundled components)
 * - Rules Libraries (Mask, Validation, Datagrid) (not required unless these components are used)
 * - Patterns
 * - Layouts
 * - Foundational Components
 * - Mid-Level Components (includes Charts)
 * - Complex Components
 */

const argv = require('yargs').argv;
const chalk = require('chalk');
const fs = require('fs');
const path = require('path');

const logger = require('./logger');

const SRC_DIR = path.join(__dirname, '..', 'src');
const TEST_ARGS = [
  'button',
  'input',
  'mask',
  'listview',
  'popupmenu'
];

/*
const requiredComponents = [];
const behaviors = [];

if (!argv.components) {

}
*/

// -------------------------------------
//   Functions
// -------------------------------------

/**
 * Returns a string with a capitalized first letter
 * @param {string} str incoming string
 * @returns {string} the capitalized string
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Checks the type of library.
// Sets to `components` if it's not a valid one.
const libTypes = ['behaviors', 'components', 'layouts', 'patterns', 'utils'];
function checkLibType(type) {
  if (libTypes.indexOf(type) < 0) {
    type = libTypes[1];
  }
  return type;
}

/**
 * Returns a string representing a valid Javascript ES6 `import` statement
 * @param {string} libFile the target library file
 * @param {string} type the type of libary file
 * @returns {string} a valid ES6 `import` statement
 */
function writeJSImportStatement(libFile, libFolder, type) {
  const constructorName = capitalize(libFile, type);
  type = checkLibType(type);
  libFile = libFile.toLowerCase();
  if (!libFolder) {
    libFolder = libFile;
  } else {
    libFolder = libFolder.toLowerCase();
  }
  return `import { ${constructorName} } from '${SRC_DIR}/${type}/${libFile}/${libFile}';`;
}

/**
 * Returns a string representing a valid SASS `@import` statement
 * @param {string} libFile the target library file
 * @param {string} type the type of libary file
 * @returns {string} a valid SASS `@import` statement
 */
function writeSassImportStatement(libFile, libFolder, type) {
  type = checkLibType(type);
  libFile = libFile.toLowerCase();
  if (!libFolder) {
    libFolder = libFile;
  } else {
    libFolder = libFolder.toLowerCase();
  }
  return `@import '${SRC_DIR}/${type}/${libFolder}/${libFile}';`;
}

/**
 * Wraps `fs.readdir` and does a recursive file search
 * @param {string} root ?
 * @param {function} filter ?
 * @param {array} files ?
 * @param {string} prefix ?
 * @returns {array} of found files
 */
function read(root, filter, files, prefix) {
  prefix = prefix || '';
  files = files || [];
  filter = filter || function (x) {
    return x[0] !== '.' && !x.endsWith('.md');
  };

  const dir = path.join(root, prefix);
  if (!fs.existsSync(dir)) {
    return files;
  }

  if (fs.statSync(dir).isDirectory()) {
    fs.readdirSync(dir)
      .filter((name, index) => filter(name, index, dir))
      .forEach((name) => {
        read(root, filter, files, path.join(prefix, name));
      });
  } else {
    files.push(prefix);
  }

  return files;
}

function searchFileNames(files, term) {
  const results = [];
  if (!Array.isArray(files) || !files.length || !term) {
    return results;
  }

  files.forEach((file) => {
    if (file.indexOf(term) > -1) {
      results.push(file);
    }
  });

  return results;
}

// -------------------------------------
//   Main
// -------------------------------------

let buildOutput = `\n${chalk.red.bold('IDS Enterprise Custom Builder')}\n\n`;

// Scan source code directories
const items = read(SRC_DIR);

const jsMatches = [];
const jQueryMatches = [];
const sassMatches = [];
TEST_ARGS.forEach((arg) => {
  const results = searchFileNames(items, arg);
  results.forEach((result) => {
    let renderTarget = jsMatches;
    if (result.indexOf('.jquery') > -1) {
      renderTarget = jQueryMatches;
    }
    if (result.endsWith('.scss')) {
      renderTarget = sassMatches;
    }
    if (renderTarget.indexOf(result) > -1) {
      return;
    }
    renderTarget.push(result);
  });
});

buildOutput += `${chalk.cyan('JS Source Code:')}\n`;
jsMatches.forEach((item) => {
  buildOutput += `${item}\n`;
});
buildOutput += '\n';

buildOutput += `${chalk.cyan('jQuery Source Code:')}\n`;
jQueryMatches.forEach((item) => {
  buildOutput += `${item}\n`;
});
buildOutput += '\n';

buildOutput += `${chalk.cyan('SASS Source Code:')}\n`;
sassMatches.forEach((item) => {
  buildOutput += `${item}\n`;
});

process.stdout.write(buildOutput);
